{"version":3,"file":"patching.js","sourceRoot":"","sources":["../../../../src/aot-clean-transformer/transform-walker/patching.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nlet unpatch: () => void = undefined;\n\nexport namespace patching {\n  export function unpathTypeScript() {\n    if (unpatch) {\n      unpatch();\n    }\n  }\n\n  export function patchTypeScript(): void {\n    if (unpatch) {\n      return;\n    }\n\n    const toMonkeyPatch = ['nodeCanBeDecorated', 'nodeIsDecorated', 'childIsDecorated', 'nodeOrChildIsDecorated'];\n    const originalPatched = toMonkeyPatch.reduce( (obj, k) => { obj[k] = ts[k]; return obj; }, {} );\n    const patching = {\n      nodeCanBeDecorated(node: ts.Node): boolean {\n        return originalPatched['nodeCanBeDecorated'](node.parent ? node : node['original']);\n      },\n      nodeIsDecorated(node: ts.Node): boolean {\n        return node.decorators !== undefined\n          && patching.nodeCanBeDecorated(node);\n      },\n      childIsDecorated(node: ts.Node): boolean {\n        switch (node.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n            return ts['forEach']((<ts.ClassDeclaration>node).members, patching.nodeOrChildIsDecorated);\n          case ts.SyntaxKind.MethodDeclaration:\n          case ts.SyntaxKind.SetAccessor:\n            return ts['forEach']((<ts.FunctionLikeDeclaration>node).parameters, patching.nodeIsDecorated);\n        }\n      },\n      nodeOrChildIsDecorated(node: ts.Node): boolean {\n        return patching.nodeIsDecorated(node) || patching.childIsDecorated(node);\n      }\n    };\n    toMonkeyPatch.forEach( k => ts[k] = patching[k]);\n\n    unpatch = () => toMonkeyPatch.forEach( k => ts[k] = originalPatched[k]);\n  }\n\n  export function patchTransformer(transformFactory: ts.TransformerFactory<any>) {\n    return (context: ts.TransformationContext) => {\n      const fn = transformFactory(context);\n      return function (file: ts.SourceFile) {\n        const sourceFile = fn(file);\n        if (sourceFile !== file) {\n          if (!sourceFile['symbol']) {\n            sourceFile['symbol'] = file['symbol'];\n          }\n          if (!sourceFile['locals']) {\n            sourceFile['locals'] = sourceFile['original']['locals'];\n          }\n        }\n        return sourceFile;\n      }\n    }\n  }\n}"]}