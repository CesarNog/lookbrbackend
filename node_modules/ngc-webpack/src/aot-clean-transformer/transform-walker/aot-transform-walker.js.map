{"version":3,"file":"aot-transform-walker.js","sourceRoot":"","sources":["../../../../src/aot-clean-transformer/transform-walker/aot-transform-walker.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport * as utils from '../utils';\nimport { BaseTransformWalker, WalkerContext } from './base-transform-walker';\nimport { MockTypeChecker } from './mock-type-checker';\n\nexport class AotWalkerContext extends WalkerContext {\n  scope: ts.SyntaxKind[] = [];\n\n  addScope(node: ts.Node): void {\n    this.scope.push(node.kind);\n  }\n\n  currentClass?: ts.ClassDeclaration;\n  currentClassParam?: ts.ParameterDeclaration;\n  currentClassProp?: ts.PropertyDeclaration;\n  currentClassMethod?: ts.MethodDeclaration;\n}\n\nlet mockTypeChecker: MockTypeChecker;\n\nexport class AotTransformWalker extends BaseTransformWalker<AotWalkerContext> {\n\n  public angularImports: string[];\n\n  private get mocker(): MockTypeChecker {\n    return mockTypeChecker || (mockTypeChecker = new MockTypeChecker(this.context.getCompilerOptions()));\n  }\n\n\n  constructor(public sourceFile: ts.SourceFile,\n              public context: ts.TransformationContext,\n              walkerContext?: WalkerContext) {\n\n    super(sourceFile, context, walkerContext || new AotWalkerContext());\n\n\n    this.angularImports = this.findAstNodes(<any>sourceFile, ts.SyntaxKind.ImportDeclaration)\n      .map((node: ts.ImportDeclaration) => utils.angularImportsFromNode(node, this.sourceFile))\n      .reduce((acc: string[], current: string[]) => acc.concat(current), []);\n\n  }\n\n  walk(): ts.Node {\n    if (this.sourceFile.fileName.endsWith('ngfactory.ts')) {\n      return this.sourceFile;\n    } else {\n      return <any>super.walk();\n    }\n  }\n\n  protected onBeforeVisitNode(node: ts.Node): void {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n        this.walkerContext.currentClass = <any>node;\n        break;\n      case ts.SyntaxKind.Parameter:\n        if (this.walkerContext.currentClass && node.decorators) {\n          this.walkerContext.currentClassParam = <any>node;\n        }\n        break;\n      case ts.SyntaxKind.PropertyDeclaration:\n        if (this.walkerContext.currentClass && node.decorators) {\n          this.walkerContext.currentClassProp = <any>node;\n        }\n        break;\n      case ts.SyntaxKind.MethodDeclaration:\n        if (this.walkerContext.currentClass && node.decorators) {\n          this.walkerContext.currentClassMethod = <any>node;\n        }\n        break;\n\n    }\n\n  }\n\n  protected onAfterVisitNode(node: ts.Node): void {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n        this.walkerContext.currentClass = undefined;\n        break;\n      case ts.SyntaxKind.Parameter:\n        this.walkerContext.currentClassParam = undefined;\n        break;\n      case ts.SyntaxKind.PropertyDeclaration:\n        this.walkerContext.currentClassProp = undefined;\n        break;\n      case ts.SyntaxKind.MethodDeclaration:\n        this.walkerContext.currentClassMethod = undefined;\n        break;\n    }\n\n  }\n\n  protected visitClassDeclaration(node: ts.ClassDeclaration) {\n    if (node.decorators && node.decorators.some( n => this.isAngularDecorator(n)) ) {\n      const members: any = node.members || [];\n      const ctorParams = this.classCtorParamsToLiteralExpressions(node);\n\n      if (ctorParams && ctorParams.length > 0) {\n        // Since we are to remove the decorators we need to preserve constructor parameter types and\n        // param decorators for angular to be able to use them at runtime.\n        //\n        // This is done by setting a static method on the class called `ctorParameters`\n        // The method returns an array of type information for each ctor param.\n        // The type information includes the type value and an array of decorator information.\n        // Decorator information holds the decorator function and arguments (metadata) used as params\n        // for the decorator factory. Decorator information exists only if the param has decorators.\n        // { type: TYPE_VALUE, decorators: [ { type: DECORATOR_VALUE: args: [...] }\n        //\n        // If the class extends a base class astatic method might fail type check when the signature\n        // of constructors does not match.\n        // Type script will complain if extending class static's ctorParameters method does not match parent\n        // If the class extends another class we do not set the `ctorParameters` function as a\n        // static class member method since it might have a different signature then the `ctorParameters`\n        // method on the parent class which leads to TS complaining\n        // instead we create an assignment to the class object right after class declaration:\n        //   export class MyClass { }\n        //   (MyClass as any).ctorParameters = function() { return [ ... ]; }\n        //\n        // `ctorParameters` does not exist on `MyClass` so we cast it to `any`\n        if (node.heritageClauses && node.heritageClauses.some( hc => hc.token === ts.SyntaxKind.ExtendsKeyword)) {\n          const statements: ts.Statement[] = [<any>super.visitClassDeclaration(<any>this.updateClassDeclaration(node, members))];\n\n          const leftSideBase = ts.createParen(ts.createAsExpression(node.name, ts.createTypeReferenceNode('any', undefined)));\n          const leftSide = ts.createPropertyAccess(leftSideBase, ts.createIdentifier('ctorParameters'));\n          const rightSide = ts.createFunctionExpression(undefined, undefined, undefined, undefined, undefined, undefined, ts.createBlock( [ts.createReturn(ts.createArrayLiteral(ctorParams))] ));\n          const statement = ts.createStatement(ts.createAssignment(leftSide, rightSide));\n          statements.push(<any>statement);\n          return statements as any;\n\n        } else {\n          const m = ts.createMethod(\n            undefined,\n            [ ts.createToken(ts.SyntaxKind.StaticKeyword) ],\n            undefined,\n            ts.createIdentifier('ctorParameters'),\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            ts.createBlock( [ts.createReturn(ts.createArrayLiteral(ctorParams))] )\n          );\n          members.push(m);\n          return super.visitClassDeclaration(<any>this.updateClassDeclaration(node, members));\n        }\n      }\n    }\n    return super.visitClassDeclaration(node);\n  }\n\n  private updateClassDeclaration(node: ts.ClassDeclaration, members: ts.NodeArray<ts.ClassElement>) {\n    const decorators = this.filterNodes(node.decorators, n => !this.isAngularDecorator(n));\n    return ts.updateClassDeclaration(\n      node,\n      decorators.length > 0 ? node.decorators : undefined,\n      node.modifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses,\n      members && members.length > 0 ? members : undefined\n    );\n  }\n\n  protected visitParameterDeclaration(node: ts.ParameterDeclaration) {\n    if (this.walkerContext.currentClassParam === node) {\n      const decorators = this.filterNodes(node.decorators, n => !this.isAngularDecorator(n));\n      if (decorators.length === 0) {\n        let newParamDec = ts.updateParameter(\n          node,\n          undefined,\n          node.modifiers,\n          node.dotDotDotToken,\n          node.name,\n          node.questionToken,\n          node.type,\n          node.initializer\n        );\n        return <any>super.visitParameterDeclaration(newParamDec);\n      }\n    }\n    return <any>super.visitParameterDeclaration(node);\n  }\n\n  protected visitPropertyDeclaration(node: ts.PropertyDeclaration) {\n    if (this.walkerContext.currentClassProp) {\n      const decorators = this.filterNodes(node.decorators, n => !this.isAngularDecorator(n) );\n      if (decorators.length === 0) {\n        const newPropDecl = ts.updateProperty(\n          node,\n          undefined,\n          node.modifiers,\n          node.name,\n          node.type,\n          node.initializer\n        );\n        return super.visitPropertyDeclaration(newPropDecl);\n      }\n    }\n    return super.visitPropertyDeclaration(node);\n  }\n\n  protected visitMethodDeclaration(node: ts.MethodDeclaration) {\n    if (this.walkerContext.currentClassMethod) {\n      const decorators = this.filterNodes(node.decorators, n => !this.isAngularDecorator(n));\n      if (decorators.length === 0) {\n        const newMethodDecl = ts.updateMethod(\n          node,\n          undefined,\n          node.modifiers,\n          node.asteriskToken,\n          node.name,\n          node.questionToken,\n          node.typeParameters,\n          node.parameters,\n          node.type,\n          node.body\n        );\n        return super.visitMethodDeclaration(newMethodDecl);\n      }\n    }\n    return super.visitMethodDeclaration(node);\n  }\n\n  protected visitDecorator(node: ts.Decorator) {\n    if (this.walkerContext.currentClass) {\n      return this.isAngularDecorator(node)\n        ? undefined\n        : node\n      ;\n    }\n\n    return node;\n  }\n\n  private isAngularDecorator(node: ts.Node): boolean {\n    return this.findAstNodes(node, ts.SyntaxKind.CallExpression)\n        .filter((node: ts.CallExpression) => {\n          const fnName = node.expression.getText(this.sourceFile);\n          if (fnName.indexOf('.') != -1) {\n            // Since this is `a.b`, see if it's the same namespace as a namespace import.\n            return this.angularImports.indexOf(fnName.replace(/\\..*$/, '') + '.') != -1;\n          } else {\n            return this.angularImports.indexOf(fnName) != -1;\n          }\n        }).length > 0;\n  }\n\n  private classCtorParamsToLiteralExpressions(classNode: ts.ClassDeclaration): ts.ObjectLiteralExpression[]  {\n    // For every classes with constructors, output the ctorParameters function which contains a list\n    // of injectable types.\n    const ctor = (this.findFirstAstNode(classNode, ts.SyntaxKind.Constructor) as ts.ConstructorDeclaration);\n    if (!ctor) {\n      // A class can be missing a constructor, and that's _okay_.\n      return [];\n    }\n\n    return Array.from(ctor.parameters)\n      .map( paramNode => this.ctorParameterFromTypeReference(paramNode) );\n  }\n\n\n  private ctorParameterFromTypeReference(paramNode: ts.ParameterDeclaration): ts.ObjectLiteralExpression {\n\n    if (!this.mocker.hasFile(this.sourceFile.fileName)) {\n      // we must use virtual files and not the actual file since previous loaders might have changed\n      // the code.\n      this.mocker.addVirtFile(this.sourceFile.fileName, this.sourceFile.text);\n    }\n\n    const typeName = this.ctorParameName(paramNode);\n\n    const decorators = this.findAstNodes(paramNode, ts.SyntaxKind.Decorator) as ts.Decorator[];\n    const objLiteralDecorators = this.decoratorsAsObjectLiteral(decorators);\n\n    // TODO: A bug in ngTools shows empty decorators array literal if there are decorators\n    // but they are not angular's decorators, i.e. custom or other 3rd party lib decorators.\n    // when fixed, uncomment this and remove the if after it.\n    // if (objLiteralDecorators.length > 0) {\n    if (decorators.length > 0) {\n      return ts.createObjectLiteral([\n        ts.createPropertyAssignment('type', ts.createIdentifier(typeName)),\n        ts.createPropertyAssignment('decorators', ts.createArrayLiteral(objLiteralDecorators))\n      ]);\n    } else {\n      return ts.createObjectLiteral([\n        ts.createPropertyAssignment('type', ts.createIdentifier(typeName))\n      ]);\n    }\n  }\n\n  private decoratorsAsObjectLiteral(decorators: ts.Decorator[]): ts.ObjectLiteralExpression[] {\n    return decorators\n      .map(decorator => {\n        const call =\n          this.findFirstAstNode(decorator, ts.SyntaxKind.CallExpression) as ts.CallExpression;\n\n        if (!call) {\n          return null;\n        }\n\n        const fnName = call.expression.getText(this.sourceFile);\n        if (this.angularImports.indexOf(fnName) === -1) {\n          return null;\n        } else {\n          return [\n            fnName,\n            call.arguments.map(x => ts.createIdentifier( x.getText(this.sourceFile) ) )\n          ];\n        }\n      })\n      .filter(x => !!x)\n      .map(([name, args]: [string, ts.Identifier[]]) => {\n        const propAssignments = [ ts.createPropertyAssignment('type', ts.createIdentifier(name)) ];\n\n        if (args && args.length > 0) {\n          propAssignments.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));\n        }\n\n        return ts.createObjectLiteral(propAssignments);\n      });\n\n  }\n\n  private ctorParameName(paramNode: ts.ParameterDeclaration): string {\n    let typeName = 'undefined';\n\n    if (paramNode.type) {\n      switch (paramNode.type.kind) {\n        case ts.SyntaxKind.TypeReference:\n          const checker: ts.TypeChecker = this.mocker.program.getTypeChecker();\n          paramNode = utils.findRemoteMatch(<any>this.mocker.getSourceFile(this.sourceFile.fileName), <any>paramNode);\n\n          const type = paramNode.type as ts.TypeReferenceNode;\n          let symbolFlags = ts.SymbolFlags.None;\n\n          if(checker) {\n            const tsType = checker.getTypeFromTypeNode(type);\n            if (tsType) {\n              symbolFlags = tsType.symbol.flags;\n            }\n          }\n\n          if ( symbolFlags && ( symbolFlags & ts.SymbolFlags.Interface\n            || symbolFlags & ts.SymbolFlags.TypeAlias\n            || symbolFlags & ts.SymbolFlags.TypeLiteral) ) {\n            typeName = 'Object';\n          } else if (type.typeName) {\n            typeName = type.typeName.getText(this.sourceFile);\n          } else {\n            typeName = type.getText(this.sourceFile);\n          }\n          break;\n        case ts.SyntaxKind.AnyKeyword:\n          typeName = 'undefined';\n          break;\n        default:\n          typeName = 'null';\n      }\n    }\n\n    return typeName;\n  }\n}\n"]}