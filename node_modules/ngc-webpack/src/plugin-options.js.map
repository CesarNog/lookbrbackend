{"version":3,"file":"plugin-options.js","sourceRoot":"","sources":["../../src/plugin-options.ts"],"names":[],"mappings":"","sourcesContent":["\nexport type ResourcePathTransformer = (path: string) => string;\n/**\n * @deprecated Use ResourcePathTransformer\n */\nexport type PathTransformer = ResourcePathTransformer;\n\nexport type ResourceTransformer = (path: string, source: string) => string | Promise<string>;\n/**\n * @deprecated Use SourceTransformer\n */\nexport type SourceTransformer = ResourceTransformer;\n\nexport type BeforeRunHandler = (loader: { get(filename: string): Promise<string> }) => Promise<void>;\nexport type ReadFileTransformer = (path: string, source: string) => string;\nexport type OnCompilationSuccess = () => void;\nexport type OnCompilationError = (err: Error) => void;\n\nexport interface NgcWebpackPluginOptions {\n  /**\n   * If false the plugin is a ghost, it will not perform any action.\n   * This property can be used to trigger AOT on/off depending on your build target (prod, staging etc...)\n   *\n   * The state can not change after initializing the plugin.\n   * @default true\n   */\n  disabled?: boolean;\n\n  /**\n   * A hook that invokes before the `compiler-cli` start the compilation process.\n   * (loader: { get(filename: string): Promise<string> }) => Promise<void>;\n   *\n   * The hook accepts an object with a `get` method that acts as a webpack compilation, being able to compile a file and return it's content.\n   * @param loader\n   */\n  beforeRun?: BeforeRunHandler\n\n  /**\n   * Transform a source file (ts, js, metadata.json, summery.json)\n   * (path: string, source: string) => string;\n   *\n   * Note that source code transformation is sync, you can't return a promise (contrary to `resourcePathTransformer`).\n   * This means that you can not use webpack compilation (or any other async process) to alter source code context.\n   * If you know the files you need to transform, use the `beforeRun` hook.\n   */\n  readFileTransformer?: ReadFileTransformer;\n\n\n  /**\n   * Transform the path of a resource (html, css, etc)\n   * (path: string) => string;\n   */\n  resourcePathTransformer?: ResourcePathTransformer;\n\n  /**\n   * Transform a resource (html, css etc)\n   * (path: string, source: string) => string | Promise<string>;\n   */\n  resourceTransformer?: ResourceTransformer;\n\n  /**\n   * @deprecated Use resourcePathTransformer\n   */\n  pathTransformer?: PathTransformer;\n  /**\n   * @deprecated Use resourceTransformer\n   */\n  sourceTransformer?: SourceTransformer;\n\n  /**\n   * Fires then the compilation ended with no errors.\n   * () => void;\n   *\n   * > If you throw from the callback the process will exit with failure and print the error message.\n   * This allows some validation for `resourcePathTransformer`, to check the state one finished and conclude about the result.\n   */\n\n  onCompilationSuccess?: OnCompilationSuccess;\n  /**\n   * Fires then the compilation ended with an error.\n   * (err: Error) => void;\n   *\n   * > If you throw from the callback the process will exit with failure and print the error message.\n   * This allows some validation for `resourcePathTransformer`, to check the state one finished and conclude about the result.\n   *\n   * > Throwing from `onCompilationError` is like re-throw with a new error.\n   * Currently it's not possible to suppress an error.\n   */\n  onCompilationError?: OnCompilationError;\n\n  /**\n   * A path to a tsconfig file, if set the AOT compilation is triggered from the plugin.\n   * When setting a tsconfig you do not need to run the compiler from the command line.\n   *\n   * If you are not setting a config file the compilation will not run and you need to run it before webpack starts.\n   * When AOT compiling outside of the plugin (i.e. no tsconfig property), you can still use the\n   * plugin to access the hooks, but remember that the hooks will run from the command line process (e.g: `ngc-w`)\n   * @default undefined\n   */\n  tsConfig?: string;\n\n  /**\n   * A path to a file (resource) that will replace all resource referenced in @Components.\n   * For each `@Component` the AOT compiler compiles it creates new representation for the templates (html, styles)\n   * of that `@Components`. It means that there is no need for the source templates, they take a lot of\n   * space and they will be replaced by the content of this resource.\n   *\n   * To leave the template as is set to a falsy value (the default).\n   *\n   * TIP: Use an empty file as an overriding resource. It is recommended to use a \".js\" file which\n   * usually has small amount of loaders hence less performance impact.\n   *\n   * > This feature is doing NormalModuleReplacementPlugin for AOT compiled resources.\n   *\n   * ### resourceOverride and assets\n   * If you reference assets in your styles/html that are not inlined and you expect a loader (e.g. url-loader)\n   * to copy them, don't use the `resourceOverride` feature as it does not support this feature at the moment.\n   * With `resourceOverride` the end result is that webpack will replace the asset with an href to the public\n   * assets folder but it will not copy the files. This happens because the replacement is done in the AOT compilation\n   * phase but in the bundling it won't happen (it's being replaced with and empty file...)\n   *\n   * @default undefined\n   */\n  resourceOverride?: string;\n\n  /**\n   * Angular compiler CLI options\n   */\n  cliOptions?: any;\n}"]}